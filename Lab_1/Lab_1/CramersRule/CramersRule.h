
#include "../Matrix/Matrix.h"

class CramersRule : public Matrix
{
public:

	/*
	В объекте хранится матрица размером Nx(N+1)
	Где первые N столбцов относятся к матрице системы, а последний столбец - свободные члены
	Сам класс реализует решение СЛАУ методом крамера
	*/

	/*
	Конструктор по умолчанию
	Создает матрицу размера  1х2 со значением 0
	*/
	CramersRule();

	/*
	конструктор с параметрами
	args:
		rows - количество строк в матрице
		cols - количество столбцов в матрице
		matrix - матрица
	выбрасывает исключение, если rows или cols меньше 0, а в matrix встречен нулевой указатель
	столбцов должно быть на 1 больше, чем строк
	*/
	CramersRule(int rows, int cols, double** matrix);

	/*
	конструктор копирования
	args:
		cramersMethod - копируемая СЛАУ
	*/
	CramersRule(const CramersRule& cramersMethod);

	/*
	Оператор присваивания матриц
	args:
		cramersMethod - копируемая СЛАУ
	return - ссылка на текущий объект
	*/
	CramersRule& operator=(const CramersRule& cramersMethod);

	/*
	Оператор присваивания матриц
	args:
		matrix - присваиваемая матрица
	return - ссылка на текущий объект
	*/
	CramersRule& operator=(const Matrix& matrix);



	/*
	изменение матрицы
	Изменяет текущую матрицу на входну
	args:
		rows - количество строк в матрице
		cols - количество столбцов в матрице
		matrix - матрица
	выбрасывает исключение, если rows или cols меньше 0, а в matrix встречен нулевой указатель
	столбцов должно быть на 1 больше, чем строк
	*/
	virtual void setMatrix(int rows, int cols, double** matrix) override;

	/*
	решение СЛАУ методом Крамера
	return - массив решений, размер которого равен количеству строк исходной матрицы
	выбрасывает исключение, если определитель матрицы равен 0
	*/
	double* compute();

	/*
	Транспонирование матрицы
	Транспонируется только та часть матрицы, которая относится к матрице системы
	Т.е. столбец свободных членов не транспонируется
	*/
	virtual void transponse() override;


	/*
	Функция вывода в консоль содержимого матрицы и класса
	Нужна для демонстрации полиморфизма
	*/
	virtual void print() override;

protected:

	/*
	Вычисление определителя матрицы
	args:
		rang - ранг матрицы
		matrix - матрица, определитель которой вычисляется
	return - значение определителя
	*/
	double determinant(int rank, double ** matrix);

	/*
	Вычисление минора элемента, стоящего в строке row и стобце col матрицы matrix ранга rank
	args:
		row - строка, в которой находится элемент, минор которого нужно вычислить
		col - столбец, в котором находится элемент, минор которого нужно вычислить
		rank - ранг матрицы, в которой находится элемент, минор которого нужно вычислить
		matrix - сама матрица ранга rank
	return - значение минора
	*/
	double minor(int row, int col, int rank, double** matrix);
};