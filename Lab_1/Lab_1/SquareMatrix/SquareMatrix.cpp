#include "SquareMatrix.h"
#include <exception>
#include <cmath>
#include <iostream>

using namespace std;

//конструктор по умолчанию
SquareMatrix::SquareMatrix(int rank, double ** matrix)
{
	//ранг матрицы не должен быть отрицательным
	if (rank <= 0)
		throw exception("Bad rank");

	//матрица не должна быть представлена нулевым указателем
	if (!matrix)
		throw exception("Nullptr matrix");

	//сохраняем ранг и копируем содержимое матрицы
	_rank = rank;
	_matrix = copyMatrix(rank, matrix);
}

//конструктор копирования
SquareMatrix::SquareMatrix(const SquareMatrix & matrix)
{
	//копируем ранг и содержимое матрицы
	_rank = matrix._rank;
	_matrix = copyMatrix(matrix._rank, matrix._matrix);
}

//деструктор
SquareMatrix::~SquareMatrix()
{
	//перед уничтожением объекта очищаем память, выделенную под матрицу
	for (int i = 0; i < _rank; i++)
		delete[] _matrix[i];
	delete[] _matrix;
}

//изменение матрицы
void SquareMatrix::setMatrix(int rank, double ** matrix)
{
	//ранг не должен быть отрицательным
	if (rank <= 0)
		throw exception("Bad rank");

	//матрица не должна быть представлена нулевым указателем
	if (!matrix)
		throw exception("Nullptr matrix");

	for (int i = 0; i < _rank; i++)
		delete[] _matrix[i];
	delete[] _matrix;

	//сохраняем ранг и содержимое матрицы
	_rank = rank;
	_matrix = copyMatrix(rank, matrix);
}

//изменение значения по индексам
void SquareMatrix::setValue(int row, int col, double value)
{
	//индекс строки не должен выходить за рамки ранга
	if ((row < 0) || (row >= _rank))
		throw exception("Bad row index");

	//индекс столбца не должен выходить за рамки ранга
	if ((col < 0) || (col >= _rank))
		throw exception("Bad col index");

	//изменяем элемент
	_matrix[row][col] = value;
}

//получение значения ранга
int SquareMatrix::getRank()
{
	return _rank;
}

//получение копии матрицы
double ** SquareMatrix::getMatrix()
{
	return copyMatrix(_rank, _matrix);
}

//получение значения по индексам
double SquareMatrix::getValue(int row, int col)
{
	//индекс строки не должен выходить за рамки ранга
	if ((row < 0) || (row >= _rank))
		throw exception("Bad row index");

	//индекс столбца не должен выходить за рамки ранга
	if ((col < 0) || (col >= _rank))
		throw exception("Bad col index");

	return _matrix[row][col];
}

//транспонирование матрицы
void SquareMatrix::transponse()
{
	int swap;
	for (int i = 0; i < _rank; i++)
		for (int j = i; j < _rank; j++)
		{
			//меняем местами элементы [i,j] и [j,i]
			swap = _matrix[i][j];
			_matrix[i][j] = _matrix[j][i];
			_matrix[j][i] = swap;
		}
}

//вычисление определителя
double SquareMatrix::determinant()
{
	//определитель матрицы, состоящей из одного элемента равен этому элементу
	if (_rank == 1)
		return _matrix[0][0];

	double det = 0;
	//раскладываем определитель по первой строке
	for (int i = 0; i < _rank; i++)
		//определить равен сумме произведений элементов строки на их миноры и на (-1)^(i+j), в нашем случае j = 0
		det += _matrix[0][i] * minor(0, i, _rank, _matrix)*pow(-1,i);

	return det;
}

//вывод на экран
void SquareMatrix::show()
{
	for (int i = 0; i < _rank; i++)
	{
		for (int j = 0; j < _rank; j++)
			cout << _matrix[i][j] << '\t';
		cout << endl;
	}
	cout << endl;
}

//скопировать матрицу
double** SquareMatrix::copyMatrix(int rank, double** matrix)
{
	//создаем такую же по размеру матрицу
	double ** copy = new double*[rank];
	for (int i = 0; i < rank; i++)
	{
		copy[i] = new double[rank];
		
		//копируем ее содержимое
		for (int j = 0; j < rank; j++)
				copy[i][j] = matrix[i][j];
	}

	//возвращаем копию
	return copy;
}

//получение минора матрицы
double SquareMatrix::minor(int row, int col, int rank, double** matrix)
{
	//минор - определить матрицы, составленной при вычеркивании строки row и столбца col из матрицы matrix

	//создаем такую же по размеру матрицу
	double** newMatrix = new double *[rank - 1];

	//перебираем все строки матрицы
	for (int i = 0, j = 0; i < rank; i++)
		//если встретилась строка под номером row, то пропускаем ее
		if (i == row)
			continue;
		else
		{
			//иначе - копируем содержимое строки за исключением столбца col
			newMatrix[j] = new double[rank - 1];
			for (int k = 0, l = 0; k < rank; k++)
				if (k == col)
					continue;
				else
					newMatrix[j][l++] = matrix[i][k];

			j++;
		}
	
	//т.к. мы вычеркнули одну строку и столбец из матрицы
	//то ее ранг уменьшился
	rank--;

	//если ранг матрицы равен 1, то она состоит из одного элемента (1х1)
	if (rank == 1)
	{
		//тогда определитель равен этому элементу
		double det = newMatrix[0][0];

		//очищаем память от созданной матрицы
		for (int i = 0; i < rank; i++)
			delete[] newMatrix[i];
		delete[] newMatrix;

		return det;
	}

	//иначе считаем определитель для данной матрицы как произведение элементов 
	//первой строки на их миноры и на (-1)^i
	double det = 0;
	for (int i = 0; i < rank; i++)
		det += newMatrix[0][i] * minor(0, i, rank, newMatrix) * pow(-1, i);

	//очищаем выделенную под матрицу память
	for (int i = 0; i < rank; i++)
		delete[] newMatrix[i];
	delete[] newMatrix;

	return det;
}
